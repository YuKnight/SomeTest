https://www.cnblogs.com/qkhh/p/4683626.html

今天看到一段3DES加密算法的代码，用的参数是DESede/CBC/PKCS5Padding，感觉比较陌生，于是学习了一下。

遇到的java代码如下：
Cipher cipher=Cipher.getInstance("DESede/CBC/PKCS5Padding");

 
以前写的代码，给的参数都是DES或DESede。实际上DESede是简写，它与DESede/ECB/PKCS5Padding等价。这个参数分为三段。
- 第一段是加密算法的名称，如DESede实际上是3-DES。这一段还可以放其它的对称加密算法，如Blowfish等。
- 第二段是分组加密的模式，除了CBC和ECB之外，还可以是NONE/CFB/QFB等。最常用的就是CBC和ECB了。DES采用分组加密的方式，将明文按8字节（64位）分组分别加密。如果每个组独立处理，则是ECB。CBC的处理方式是先用初始向量IV对第一组加密，再用第一组的密文作为密钥对第二组加密，然后依次完成整个加密操作。如果明文中有两个分组的内容相同，ECB会得到完全一样的密文，但CBC则不会。
- 第三段是指最后一个分组的填充方式。大部分情况下，明文并非刚好64位的倍数。对于最后一个分组，如果长度小于64位，则需要用数据填充至64位。PKCS5Padding是常用的填充方式，如果没有指定，默认的方式就是它。

补充一点，虽然DES的有效密钥长度是56位，但要求密钥长度是64位（8字节）。3DES则要求24字节。

C#
有时候java加密的内容用C#解密不了，一般原因都是设定的参数不正确。C#获取的TripleDES对象必需设定Mode和Padding两个属性。Mode和Padding是枚举类型。Mode有对应的ECB和CBC对应的枚举值，但Padding的PKCS5Padding需要对应PKCS7。

示例代码
TripleDES d = TripleDES.Create();
d.Mode = CipherMode.CBC;
d.Padding = PaddingMode.PKCS7;




[加密数据的填充方式(Padding)](https://blog.csdn.net/shift_wwx/article/details/84256774)
常用的填充模式至少有5种，不同的编程语言实现加密时用到的填充多来于这些方式或他们的变化。

1. 常用的填充形式
1. 1 填充数据为填充字节的长度
这种填充方式中，填充字符串由一个字节序列组成，每个字节填充该字节序列的长度。假定块长度为8，原文数据长度9，则填充字节数等于0x07；如果明文数据长度为8的整数倍，则填充字节数为0x08。

填充字符串如下：
原文数据1：  FF FF FF FF FF FF FF FF FF
填充后数据1：FF FF FF FF FF FF FF FF FF 07 07 07 07 07 07 07

原文数据2：  FF FF FF FF FF FF FF FF
填充后数据2：FF FF FF FF FF FF FF FF 08 08 08 08 08 08 08 08

1.2 填充数据为0x80后加0x00
这种填充方式中，填充字符串的第一个字节数是0x80，后面的每个字节是0x00。假定块长度为8，原文数据长度为9或者为8的整数倍，则填充字符串如下：
原文数据1：  FF FF FF FF FF FF FF FF FF
填充后数据1：FF FF FF FF FF FF FF FF FF 80 00 00 00 00 00 00

原文数据2：  FF FF FF FF FF FF FF FF
填充后数据2：FF FF FF FF FF FF FF FF 80 00 00 00 00 00 00 00

1.3 填充数据的最后一个字节为填充字节序列的长度
这种填充方式中，填充字符串的最后一个字节为该字节序列的长度，而前面的字节可以是0x00，也可以是随机的字节序列。假定块长度为8，原文数据长度为9或者为8的整数倍，则填充字符串如下：
原文数据1：  FF FF FF FF FF FF FF FF FF
填充后数据1：FF FF FF FF FF FF FF FF FF 00 00 00 00 00 00 07
         或
             FF FF FF FF FF FF FF FF FF 58 B3 98 9B AD F4 07

原文数据2：  FF FF FF FF FF FF FF FF
填充后数据2：FF FF FF FF FF FF FF FF 00 00 00 00 00 00 00 08
         或
             FF FF FF FF FF FF FF FF 32 58 B3 98 9B AD F4 08


1.4 填充数据为空格
这种填充方式中，填充字符串的每个字节为空格对应的字节数0x20。假定块长度为8，原文数据长度为9或者为8的整数倍，则填充字符串如下：

原文数据1：  FF FF FF FF FF FF FF FF FF
填充后数据1：FF FF FF FF FF FF FF FF FF 20 20 20 20 20 20 20

原文数据2：  FF FF FF FF FF FF FF FF
填充后数据2：FF FF FF FF FF FF FF FF 20 20 20 20 20 20 20 20

1.5 填充数据为0x00
这 种 填 充 方 式 中 ，填 充 字 符 串 的 每 个 字 节 为0x00。假定块长度为8，原文数据长度为9或者8的整数倍，则填充字符串如下：

原文数据1：  FF FF FF FF FF FF FF FF FF
填充后数据1：FF FF FF FF FF FF FF FF FF 00 00 00 00 00 00 00

原文数据2：  FF FF FF FF FF FF FF FF
填充后数据2：FF FF FF FF FF FF FF FF 00 00 00 00 00 00 00 00

在填充方式 4 和方式 5 中，由于缺少填充数据长度的标识信息，如果原文数据的后几个字节本身包括空格或0，将不能够准确移去填充的数据。因此使用这样的填充方式时，对原文数据有一定的要求。

2. 常用的填充方式
2.1 ISO10126Padding
与上面1.3 节的填充方式相对应。

2.2 PKCS5Padding
PKCS5Padding或PKCS7Padding是RSA公司的公钥密码学标准PKCS #5文档中定义的填充方式，与上面1.1 节中的填充方式相对应。

2.3 PKCS1Padding
PKCS1Padding 是RSA公司的公钥密码学标准PKCS #1文档中定义的填充方式，是RSA 算法实现加密操作常用的填充方式。

加密块是8 位字节串EB，它由块标记BT、填充块PS和数据D 组成。即EB=00 || BT || PS || 00 || D。其中BT 是一个标记字节，表示加密块的结构。BT 有 3 个值，00、01 和02，其中私钥操作为00 或01，公钥操作为02。PS 为填充数据，对于BT 为00，填充数据为0x00；对于BT 为01，填充为0xFF；对于BT 为02，填充为假散列生成的非0值。
PKCS#1(v1.5)中规定当RSA的密钥长度是1024b,如果使用PKCS1Padding填充，则原文数据最多117B。如果原文不满足长度要求，则在加密前需要进行填充。假定原文数据长度为96 B，则填充处理后字符串分别如下：

原文数据：
61 62 63 64 65 66 67 68 69 6A 6B 6C 6D 6E 6F 70 71 72 73 74 75 76 77 78 79 7A 30 31 32 33 34
35 61 62 63 64 65 66 67 68 69 6A 6B 6C 6D 6E 6F 70 71 72 73 74 75 76 77 78 79 7A 30 31 32 33
34 35 61 62 63 64 65 66 67 68 69 6A 6B 6C 6D 6E 6F 70 71 72 73 74 75 76 77 78 79 7A 30 31 32
33 34 35
私钥操作，00型，填充后数据：

00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
61 62 63 64 65 66 67 68 69 6A 6B 6C 6D 6E 6F 70 ……
私钥操作，01型，填充后数据：

00 01 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF 00
61 62 63 64 65 66 67 68 69 6A 6B 6C 6D 6E 6F 70 ……
公钥操作，02型，填充后数据：

00 02 58 DE B9 E7 15 46 16 D9 74 9D EC BE C0 EA B5 EC BB B5 0D C4 29 95 6C 18 17 BE 41 57 19 00
61 62 63 64 65 66 67 68 69 6A 6B 6C 6D 6E 6F 70 …
…
从填充后的数据可以看出，对于00型的私钥操作，要求原文数据必须不能包含0x00,或者知晓数据长度，否则将不能准确移去填充数据。因此在加解密操作中，常使用01型的私钥操作和02型的公钥操作。

3. 块大小设置
块的大小根据算法需求来决定。
例如，AES 的数据块是128bits，也就是16B，所以，块的大小是16字节。
例如，DES 的数据块是64bits，也就是8 B，所以，块的大小是8字节。
另外，填充模式一般针对的是块加密模式(分组加密模式)，MD5、SHA等散列方式没有填充模式。



加解密转换时的问题 
https://bbs.csdn.net/topics/390108058

原来是key补全方式不匹配.

3des的注意的地方.
1.mode <ecb, cbc其他?>
1.data补齐方式. (java一般使用DESede/ECB/PKCS5Padding. 用其他语言实现与java对接时, 需依次.)
2.key补齐方式.(一般会具体规定. 补0或者 字符'0').

此次出现不匹配是因为规定用字符'0', 但是C code中却使用 0 补齐.











https://blog.csdn.net/aaaaatiger/article/details/2525561

分组加密的四种模式(ECB、CBC、CFB、OFB)
https://blog.csdn.net/includeiostream123/article/details/51066799

加密一般分为对称加密(Symmetric Key Encryption)和非对称加密(Asymmetric Key Encryption)。
对称加密又分为分组加密和序列密码。
分组密码，也叫块加密(block cyphers)，一次加密明文中的一个块。是将明文按一定的位长分组，明文组经过加密运算得到密文组，密文组经过解密运算（加密运算的逆运算），还原成明文组。
序列密码，也叫流加密(stream cyphers)，一次加密明文中的一个位。是指利用少量的密钥（制乱元素）通过某种复杂的运算（密码算法）产生大量的伪随机位流，用于对明文位流的加密。
解密是指用同样的密钥和密码算法及与加密相同的伪随机位流，用以还原明文位流。

分组加密算法中，有ECB,CBC,CFB,OFB这几种算法模式。

1)ECB(Electronic Code Book)/电码本模式
DES ECB（电子密本方式）其实非常简单，就是将数据按照8个字节一段进行DES加密或解密得到一段8个字节的密文或者明文，最后一段不足8个字节，按照需求补足8个字节进行计算，之后按照顺序将计算所得的数据连在一起即可，各段数据之间互不影响。

特点：
1.简单，有利于并行计算，误差不会被传送；
2.不能隐藏明文的模式；
repetitions in message may show in cipher text/在密文中出现明文消息的重复 
3.可能对明文进行主动攻击；
加密消息块相互独立成为被攻击的弱点/weakness due to encrypted message blocks being independent


2)CBC(Cipher Block Chaining)/密文分组链接方式
DES CBC（密文分组链接方式）有点麻烦，它的实现机制使加密的各段数据之间有了联系。其实现的机理如下：

加密步骤如下：
1）首先将数据按照8个字节一组进行分组得到D1D2......Dn（若数据不是8的整数倍，用指定的PADDING数据补位）
2）第一组数据D1与初始化向量I异或后的结果进行DES加密得到第一组密文C1（初始化向量I为全零）
3）第二组数据D2与第一组的加密结果C1异或以后的结果进行DES加密，得到第二组密文C2
4）之后的数据以此类推，得到Cn
5）按顺序连为C1C2C3......Cn即为加密结果。

解密是加密的逆过程，步骤如下：
1）首先将数据按照8个字节一组进行分组得到C1C2C3......Cn
2）将第一组数据进行解密后与初始化向量I进行异或得到第一组明文D1（注意：一定是先解密再异或）
3）将第二组数据C2进行解密后与第一组密文数据进行异或得到第二组数据D2
4）之后依此类推，得到Dn
5）按顺序连为D1D2D3......Dn即为解密结果。

这里注意一点，解密的结果并不一定是我们原来的加密数据，可能还含有你补得位，一定要把补位去掉才是你的原来的数据。
特点：
1. 不容易主动攻击,安全性好于ECB,适合传输长度长的报文,是SSL、IPSec的标准。
each ciphertext block depends on all message blocks/每个密文块依赖于所有的信息块
thus a change in the message affects all ciphertext blocks/明文消息中一个改变会影响所有密文块
2. need Initial Vector (IV) known to sender & receiver/发送方和接收方都需要知道初始化向量 
3.加密过程是串行的，无法被并行化(在解密时，从两个邻接的密文块中即可得到一个平文块。因此，解密过程可以被并行化)。


3)Cipher Feedback (CFB)/密文反馈模式
密文反馈（CFB，Cipher feedback）模式类似于CBC，可以将块密码变为自同步的流密码；工作过程亦非常相似，CFB的解密过程几乎就是颠倒的CBC的加密过程：
需要使用一个与块的大小相同的移位寄存器，并用IV将寄存器初始化。然后，将寄存器内容使用块密码加密，然后将结果的最高x位与平文的x进行异或，以产生密文的x位。下一步将生成的x位密文移入寄存器中，并对下面的x位平文重复这一过程。解密过程与加密过程相似，以IV开始，对寄存器加密，将结果的高x与密文异或，产生x位平文，再将密文的下面x位移入寄存器。
与CBC相似，平文的改变会影响接下来所有的密文，因此加密过程不能并行化；而同样的，与CBC类似，解密过程是可以并行化的。


4)Output Feedback (OFB)/输出反馈模式
输出反馈模式（Output feedback, OFB）可以将块密码变成同步的流密码。它产生密钥流的块，然后将其与平文块进行异或，得到密文。与其它流密码一样，密文中一个位的翻转会使平文中同样位置的位也产生翻转。这种特性使得许多错误校正码，例如奇偶校验位，即使在加密前计算而在加密后进行校验也可以得出正确结果。
每个使用OFB的输出块与其前面所有的输出块相关，因此不能并行化处理。然而，由于平文和密文只在最终的异或过程中使用，因此可以事先对IV进行加密，最后并行的将平文或密文进行并行的异或处理。
可以利用输入全0的CBC模式产生OFB模式的密钥流。这种方法十分实用，因为可以利用快速的CBC硬件实现来加速OFB模式的加密过程。
